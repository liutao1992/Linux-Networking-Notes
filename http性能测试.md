## HTTP性能测试

### 文件描述符

在 Linux 系统中，文件描述符（File Descriptor, FD）是操作系统用来表示打开文件、套接字、管道等资源的整数标识符。每个进程在打开文件或创建网络连接时，都会分配一个文件描述符。由于文件描述符的数量是有限的，如果不合理管理，系统可能会因为达到文件描述符上限而出现问题，比如 "too many open files" 错误。

### 操作系统文件描述符使用情况的监控与管理：

#### 1. **查看当前系统的文件描述符限制**

Linux 系统对每个进程可以打开的文件描述符数量有限制。你可以通过 `ulimit` 命令查看和修改该限制。

- 查看当前用户可以使用的最大文件描述符数：

  ```bash
  ulimit -n
  ```

  这会显示当前用户进程可以打开的文件描述符数量上限。

- 查看系统全局的文件描述符限制：

  ```bash
  cat /proc/sys/fs/file-max
  ```

  这会显示整个系统范围内的文件描述符上限。这个值控制整个系统可以打开的文件描述符数量总和。

#### 2. **查看某个进程的文件描述符使用情况**

每个进程都有一个独立的文件描述符集。可以使用以下命令查看某个特定进程的文件描述符使用情况：

- 获取进程的文件描述符使用数：

  ```bash
  ls /proc/<PID>/fd | wc -l
  ```

  其中，`<PID>` 是目标进程的进程 ID。例如，想查看 NGINX 进程（假设其 PID 是 1234）的文件描述符使用情况：

  ```bash
  ls /proc/1234/fd | wc -l
  ```

  `/proc/<PID>/fd` 目录包含了该进程打开的所有文件描述符。

#### 3. **实时监控系统文件描述符的使用情况**

可以通过以下命令查看当前系统范围内使用的文件描述符数量以及总限制：

- 查看当前系统正在使用的文件描述符总数：

  ```bash
  cat /proc/sys/fs/file-nr
  ```

  输出示例：

  ```
  2345    0   123456
  ```

  解释：
  - 第一个数字 `2345`：当前已分配的文件描述符数量。
  - 第二个数字 `0`：未使用的文件描述符数量（通常显示为 0）。
  - 第三个数字 `123456`：系统可以打开的最大文件描述符数量（与 `file-max` 的值一致）。

#### 4. **修改文件描述符限制**

##### 临时修改（当前会话生效）

- 修改当前用户的文件描述符限制，可以通过 `ulimit` 进行临时设置：

  ```bash
  ulimit -n 65535
  ```

  这会将当前用户的文件描述符限制提升至 65535。这个设置在用户登出或系统重启后会恢复默认值。

##### 永久修改（系统重启后生效）

- 修改 `/etc/security/limits.conf` 文件，增加以下配置来永久提升文件描述符的限制：

  ```bash
  * soft nofile 65535
  * hard nofile 65535
  ```

  - `*` 表示对所有用户生效，可以指定具体用户名。
  - `soft nofile` 表示软限制，即用户进程能打开的文件描述符数。
  - `hard nofile` 表示硬限制，即系统层面能打开的最大文件描述符数。


##### 针对某些服务修改（如 NGINX、MySQL）

对于特定的服务进程，也可以在它们的启动脚本或服务配置文件中设置文件描述符限制。例如，在 `systemd` 管理的服务中，你可以编辑 `/etc/systemd/system/<service>.service`，为 NGINX 或其他服务指定文件描述符限制：

- 添加或修改以下行：

  ```ini
  [Service]
  LimitNOFILE=65535
  ```

  然后重启服务和 `systemd` 守护进程以使配置生效：

  ```bash
  systemctl daemon-reload
  systemctl restart nginx
  ```

#### 5. **监控系统资源的工具**

可以使用一些工具来实时监控系统的文件描述符使用情况和其他资源指标：

- **`lsof`**: 用于查看系统中打开的文件描述符。
  
  ```bash
  lsof | wc -l  # 查看当前系统中所有打开的文件描述符数量
  ```

- **`iotop`**: 实时查看进程的 I/O 使用情况。
- **`htop`**: 实时查看系统的资源使用情况，包括 CPU、内存和打开的文件描述符等。

---

通过这些方法，你可以查看、修改和监控系统的文件描述符使用情况，确保服务器能合理管理并发连接和文件操作，避免由于文件描述符不足导致的系统瓶颈问题。


### 本地端口耗尽

检查并调整 Linux 系统的本地端口范围，可以帮助确保系统能够为新的网络连接分配足够的可用端口。默认情况下，系统可能会有较小的本地端口范围，当客户端发起大量连接时，可能会耗尽可用端口，导致无法建立新的连接。

#### **步骤 1：检查当前的端口范围**

要检查当前系统分配的本地端口范围，可以使用以下命令：

```bash
sysctl net.ipv4.ip_local_port_range
```

或者直接查看内核配置文件：

```bash
cat /proc/sys/net/ipv4/ip_local_port_range
```

**输出示例**：
```
net.ipv4.ip_local_port_range = 32768 60999
```

这个输出表示本地端口的可用范围是从 `32768` 到 `60999`。可用的端口范围决定了可以分配给客户端的临时端口数量。

#### **步骤 2：计算当前可用端口数**

你可以计算当前的端口范围内的可用端口数：

```bash
echo $((60999 - 32768 + 1))
```

**结果**：28332

这表示当前系统有 28332 个可用的端口。如果你有大量短时间内创建和关闭的连接，这个端口数量可能不够。

#### **步骤 3：查看本地端口使用情况**

```bash
liutao@liu:~/workspace/web$ ss -s
Total: 28410
TCP:   28244 (estab 28234, closed 3, orphaned 0, timewait 0)

Transport Total     IP        IPv6
RAW       1         0         1        
UDP       2         2         0        
TCP       28241     28238     3        
INET      28244     28240     4        
FRAG      0         0         0    
```

根据你提供的 `ss -s` 命令输出，这是系统当前的套接字（socket）统计信息。以下是每个字段的详细说明：

#### 总览：
- **Total: 28410**：当前系统中所有类型的套接字总数。
- **TCP: 28244 (estab 28234, closed 3, orphaned 0, timewait 0)**：
  - **TCP: 28244**：当前所有 TCP 套接字的总数。
  - **estab 28234**：处于已建立连接状态的 TCP 套接字数量。
  - **closed 3**：处于关闭状态的 TCP 套接字数量。
  - **orphaned 0**：孤立的套接字数量（一般指失去父进程的套接字）。
  - **timewait 0**：处于 `TIME_WAIT` 状态的 TCP 套接字数量（等待超时的连接，防止旧数据包的干扰）。

#### 按协议统计：
- **Transport**：传输层协议类型。
- **Total**：该类型的总套接字数。
- **IP**：使用 IPv4 的套接字数。
- **IPv6**：使用 IPv6 的套接字数。
  
  - **RAW 1 (IPv6: 1)**：一个原始套接字，使用 IPv6。
  - **UDP 2 (IPv4: 2)**：两个 UDP 套接字，使用 IPv4。
  - **TCP 28241 (IPv4: 28238, IPv6: 3)**：28241 个 TCP 套接字，其中 28238 个使用 IPv4，3 个使用 IPv6。
  - **INET 28244 (IPv4: 28240, IPv6: 4)**：基于 `INET` 协议族（IPv4 或 IPv6）的总套接字数。  
  - **FRAG 0**：当前没有碎片套接字（涉及 IP 数据包分片）。

#### 注意事项：
1. **高 TCP 连接数量**：你有 28234 个已建立的 TCP 连接，这可能表示一个高流量的网络服务器或者某些连接未正确关闭。你可以使用 `ss -tn` 或 `netstat -tn` 命令进一步检查这些连接。
2. **无孤立套接字**：孤立套接字（`orphaned`）为 0，表示没有失去父进程的套接字，连接管理良好。
3. **没有碎片 IP**：没有碎片（`FRAG`），表示当前没有需要重组的 IP 数据包。

你可以通过这些信息来了解系统的网络状况，排查潜在的网络问题。

#### **步骤 4：修改本地端口范围**

这样就将本地端口范围扩展为从 1024 到 65535，增加了系统可用的端口数量。如果需要更大范围的可用端口（例如增加到 `1024` 到 `65535`），你可以临时修改端口范围：

```bash
sudo sysctl -w net.ipv4.ip_local_port_range="1024 65535"
```

#### **步骤 5：永久修改端口范围**

如果你希望这个更改在系统重启后仍然有效，需要将其写入 `/etc/sysctl.conf` 文件：

1. 打开 `/etc/sysctl.conf` 文件：
   ```bash
   sudo nano /etc/sysctl.conf
   ```

2. 添加或修改以下行：
   ```
   net.ipv4.ip_local_port_range = 1024 65535
   ```

3. 保存并退出文件，然后应用更改：
   ```bash
   sudo sysctl -p
   ```

#### **步骤 6：验证修改**

再次运行以下命令，确认端口范围已经成功修改：

```bash
sysctl net.ipv4.ip_local_port_range
```

确保输出反映了你所设定的端口范围。

#### **总结**

通过调整本地端口范围，系统可以为新的网络连接分配更多的可用端口，这将减少端口耗尽导致的连接问题。在高并发的环境下，合理调整端口范围非常重要。


### TCP连接队列（backlog）限制

在 TCP 协议中，backlog 是一个重要的参数，它用于控制服务器端接受新连接时的队列长度限制。它主要涉及两个队列：半连接队列（SYN 队列）和全连接队列（Accept 队列）


#### TCP 连接队列的工作原理

当服务器调用 listen 函数来监听某个端口时，它会为该端口分配两个队列：

##### 1.1 半连接队列（SYN Queue）

半连接队列用于存放尚未完成三次握手的连接（`SYN_RECV` 状态）。这些连接只收到了客户端发来的 `SYN`，服务器已经回复了 `SYN + ACK`，但还没有收到客户端的 ACK，因此处于未完成状态。

最大长度：由内核参数 `net.ipv4.tcp_max_syn_backlog` 控制，默认值通常为 128 或 1024（不同的系统有不同的默认值）。
当队列满时：如果半连接队列已满，新来的 SYN 请求会被丢弃，客户端会在重试多次后收到连接超时的错误。
##### 1.2 全连接队列（Accept Queue）
描述：全连接队列用于存放已完成三次握手的连接，这些连接已经完全建立，但还没有被应用程序调用 accept() 函数处理。
最大长度：由应用程序在 listen 函数中指定的 backlog 参数控制，但实际限制是系统参数 `net.core.somaxconn` 的值。即 `backlog` 的实际生效值为 `min(backlog, somaxconn)`。
当队列满时：如果全连接队列已满，新的连接会被丢弃，客户端会收到 `ECONNREFUSED` 错误。


##### 2. **设置和查看连接队列大小**

##### 2.1 **应用程序中的 `backlog` 参数**

在服务器程序中（如使用 `socket` 库），你可以在调用 `listen()` 函数时指定 `backlog` 参数。该参数定义了全连接队列的大小。

```c
int listen(int sockfd, int backlog);
```

- `sockfd`：套接字描述符。
- `backlog`：请求队列的最大长度。

例如：

```c
listen(sockfd, 1024);
```

这意味着全连接队列最多可以存储 1024 个已完成的连接。

##### 2.2 **系统参数设置**

系统内核参数会限制应用程序中 `backlog` 参数的最大值。如果应用程序中 `backlog` 设置得很大，但 `net.core.somaxconn` 较小，则 `net.core.somaxconn` 的值会作为实际限制。

- **查看 `somaxconn` 值**：
  ```bash
  sysctl net.core.somaxconn
  ```

- **修改 `somaxconn` 值**（临时）：
  ```bash
  sudo sysctl -w net.core.somaxconn=2048
  ```

- **永久修改**：
  编辑 `/etc/sysctl.conf` 文件，添加以下内容：
  ```
  net.core.somaxconn = 2048
  ```
  然后运行以下命令使配置生效：
  ```bash
  sudo sysctl -p
  ```

##### 2.3 **查看 `tcp_max_syn_backlog` 值**

- **查看 `tcp_max_syn_backlog` 的当前值**：
  ```bash
  sysctl net.ipv4.tcp_max_syn_backlog
  ```

- **修改 `tcp_max_syn_backlog` 值**（临时）：
  ```bash
  sudo sysctl -w net.ipv4.tcp_max_syn_backlog=2048
  ```

- **永久修改**：
  编辑 `/etc/sysctl.conf` 文件，添加以下内容：
  ```
  net.ipv4.tcp_max_syn_backlog = 2048
  ```
  然后运行以下命令使配置生效：
  ```bash
  sudo sysctl -p
  ```

##### 3. **`backlog` 的实际使用注意事项**

1. **`backlog` 参数的限制**：
   - 如果应用程序设置的 `backlog` 超过 `net.core.somaxconn` 的值，那么实际的 `backlog` 大小将受到 `net.core.somaxconn` 的限制。
   - 对于 Linux 3.5 之前的内核，`backlog` 值为 0 或 1 时，系统会将其视为 `min(1, somaxconn)`。在 3.5 及之后的内核中，`backlog` 最小值为 1。

2. **客户端重试行为**：
   - 当服务器端的半连接队列已满时，新连接的 `SYN` 包会被丢弃，客户端会多次重试发送 `SYN`，但最终会超时或被拒绝。
   - 当全连接队列已满时，新连接会被服务器端直接拒绝，客户端会收到 `ECONNREFUSED` 错误。

3. **高并发场景下的调优**：
   - 在高并发的服务器中，如果连接建立和断开频繁，可能会积累大量 `TIME_WAIT` 状态的连接，这可能导致端口被占用，队列过多。在这种情况下，适当增大 `tcp_max_syn_backlog` 和 `somaxconn` 的值非常重要。

4. **`tcp_abort_on_overflow` 参数**：
   - 如果启用 `tcp_abort_on_overflow`（`1`），当全连接队列溢出时，服务器会主动发送 `RST` 包断开连接，客户端会立即收到连接被重置的错误。
   - 可以使用以下命令启用：
     ```bash
     sudo sysctl -w net.ipv4.tcp_abort_on_overflow=1
     ```
   - 这个选项可能会导致连接大量重置，慎重使用。

##### 4. **调优策略建议**

- **合理设置 `backlog` 参数**：根据应用程序的连接数和系统资源情况，合理设置 `listen()` 中的 `backlog` 参数，并确保 `net.core.somaxconn` 足够大。
- **调大 `tcp_max_syn_backlog`**：在高并发场景下，适当增大 `tcp_max_syn_backlog`，以防止半连接队列溢出。
- **关注系统资源**：提高 `backlog` 队列的同时，也要关注系统资源（如文件描述符、内存等）的消耗情况，以防止资源耗尽。

通过合理的 `backlog` 设置和内核参数调整，可以有效地提升服务器在高并发场景下的连接处理能力。


### 查看全连接队列（Accept Queue）的使用情况：


`ss -lt` 命令的输出中，`Recv-Q` 和 `Send-Q` 表示每个监听套接字的接收队列和发送队列的当前使用情况。以下是对你的输出的分析：

```bash
liutao@liutao:~$ ss -lt
State          Recv-Q         Send-Q                 Local Address:Port                   Peer Address:Port         Process         
LISTEN         0              511                          0.0.0.0:http                        0.0.0.0:*                            
LISTEN         0              4096                   127.0.0.53%lo:domain                      0.0.0.0:*                            
LISTEN         0              128                          0.0.0.0:ssh                         0.0.0.0:*                            
LISTEN         0              511                          0.0.0.0:8000                        0.0.0.0:*                            
LISTEN         0              511                             [::]:http                           [::]:*                            
LISTEN         0              128                             [::]:ssh                            [::]:*                            
LISTEN         0              511                             [::]:8000                           [::]:*     
```

- **Recv-Q**：表示接收队列的当前使用情况，即当前等待被服务器接受（accept）的连接数。如果这个值接近 `Send-Q` 的最大值（即 backlog 值），则可能存在队列溢出的问题。

- **Send-Q**：表示发送队列的长度，即 backlog 值。这表示了服务器在单个监听套接字上能够处理的最大连接数。

从你的输出中可以看出以下几条信息：

1. **0.0.0.0:http 和 [::]:http**
   - `Recv-Q: 0`：当前没有待处理的连接。
   - `Send-Q: 511`：backlog 值设置为 511，表示最多可以有 511 个连接等待被接受。

2. **127.0.0.53%lo:domain**
   - `Recv-Q: 0`：没有待处理的连接。
   - `Send-Q: 4096`：backlog 值为 4096，这是一个比较大的值，通常是 DNS 服务使用的设置。

3. **0.0.0.0:ssh 和 [::]:ssh**
   - `Recv-Q: 0`：没有待处理的连接。
   - `Send-Q: 128`：backlog 值为 128，表示 SSH 服务可以同时处理最多 128 个待接受的连接。

4. ***:8000**
   - `Recv-Q: 0`：没有待处理的连接。
   - `Send-Q: 10`：backlog 值为 10，表示该端口上最多可以有 10 个连接等待被接受。

### 可能的问题和优化建议：

1. **backlog 值优化：**
   - 如果发现 `Recv-Q` 接近 `Send-Q`（最大 backlog 值），则说明有可能出现队列溢出，应该考虑增加 backlog 的大小。

2. **监控队列使用情况：**
   - 定期使用 `ss -lt` 或者 `ss -s` 来查看队列的使用情况，了解当前的连接数是否接近系统的极限。

3. **调整 `somaxconn` 参数：**
   - 可以通过以下命令调整系统的全连接队列最大长度（默认为 128），以避免因队列长度不足导致的连接丢失：
     ```bash
     sysctl -w net.core.somaxconn=1024
     ```

4. **TCP 参数优化：**
   - 可以查看和优化 `tcp_max_syn_backlog` 等参数，提升系统的连接处理能力：
     ```bash
     sysctl -w net.ipv4.tcp_max_syn_backlog=2048
     ```

在实际操作中，需要根据应用的具体需求和流量特点来调整这些参数。

理解 `Recv-Q` 和 `Send-Q` 的关键在于理解 Linux 中监听（LISTEN）队列的工作原理。在 TCP 连接的建立过程中，存在两个队列：**半连接队列（SYN Queue）** 和 **全连接队列（Accept Queue）**。我们主要关注的是全连接队列，也称为接收队列。

### `Recv-Q` 和 `Send-Q` 的含义

- **`Recv-Q`**（接收队列）：表示当前在这个套接字上排队等待被服务器 `accept()` 的连接数，即还没有被应用层处理的连接数。换句话说，`Recv-Q` 表示有多少个连接已经建立，但还没有被你的应用程序接受（accept）。

- **`Send-Q`**（发送队列）：在 `ss -lt` 输出中，表示监听套接字（LISTEN 状态）的 backlog 值。backlog 值是一个参数，用来设置全连接队列的最大长度。它决定了在应用程序处理连接之前，系统能够存储的最大待处理连接数。

### 如何理解“如果 `Recv-Q` 接近 `Send-Q` 的最大值，则可能存在队列溢出的问题”

1. **连接建立过程：**
   - 当客户端发起 TCP 连接时，服务端会将其放入半连接队列（SYN Queue）。
   - 经过三次握手后，连接从半连接队列移动到全连接队列（Accept Queue）。
   - 服务器应用程序使用 `accept()` 系统调用来处理全连接队列中的连接。

2. **`Recv-Q` 的含义：**
   - `Recv-Q` 表示当前全连接队列中等待被 `accept()` 的连接数。如果 `Recv-Q` 过大，说明应用程序处理连接的速度慢，有很多连接已经建立但没有被及时处理。

3. **`Send-Q` 的含义：**
   - `Send-Q` 表示全连接队列的最大长度，也就是 backlog 值。它表示系统允许的最大未处理连接数。

4. **队列溢出：**
   - 当 `Recv-Q` 的值接近 `Send-Q`（backlog 值）时，意味着接收队列已经接近满负荷。如果 `Recv-Q` 达到 `Send-Q` 的最大值，新的连接将无法进入队列，会被拒绝或丢弃。这就是“队列溢出”问题。

### 举例说明

假设：
- `Recv-Q = 500`
- `Send-Q = 511`

- 这表示当前有 500 个连接在等待被 `accept()`，而最大可以等待的连接数是 511。`Recv-Q` 接近 `Send-Q` 的最大值，说明服务器可能出现了性能瓶颈，连接无法及时处理。如果再有 11 个新的连接进来，全连接队列就会满，导致新连接被丢弃。

### 如何处理队列溢出

1. **增加 `backlog` 值：** 增加 `Send-Q` 的最大值，可以通过调整 `listen` 函数的第二个参数或修改 `somaxconn` 的值：

   ```bash
   sysctl -w net.core.somaxconn=1024
   ```

2. **优化应用程序：** 确保应用程序及时调用 `accept()` 来处理连接，避免连接长时间在队列中等待。

3. **系统调优：** 调整 `tcp_max_syn_backlog` 等参数，提升系统的连接处理能力。

希望这样解释能够帮助你更好地理解 `Recv-Q` 和 `Send-Q` 的含义！

### 优化内核参数：

修改内核参数，以支持大量并发连接。编辑 /etc/sysctl.conf，添加以下内容：

#### 1. `net.core.somaxconn`
- **定义**: 此参数定义了每个套接字监听队列的最大长度。
- **作用**: 当一个服务器在等待接收新连接时，操作系统会将这些连接放入一个队列中。`somaxconn` 设置了这个队列的最大容量。如果连接请求超过这个数量，新的连接请求将被拒绝或丢弃。
- **建议值**: 将其设置为较高值（如 65535），可以确保在高并发情况下，服务器能够接收更多的连接请求。

#### 2. `net.core.netdev_max_backlog`
- **定义**: 此参数指定了网络设备接收队列的最大长度。
- **作用**: 在网络流量很高时，网络设备的接收缓冲区可能会满。这时新的到达数据包会被丢弃，导致数据丢失。`netdev_max_backlog` 设置了网络设备在转发数据包时可以存放的最大数据包数量。
- **建议值**: 设置为较高值（如 65535），以防止在高流量时出现丢包现象。

#### 3. `net.ipv4.tcp_max_syn_backlog`
- **定义**: 此参数控制 TCP 连接的最大 SYN 请求数量。
- **作用**: 在 TCP 握手过程中，当客户端发送 SYN 包并等待服务器确认时，服务器将该连接请求放入一个 SYN 队列中。`tcp_max_syn_backlog` 设置了这个队列的最大长度。
- **建议值**: 提高此值（如 65535）可以防止在高并发情况下 SYN 洪水攻击或合法连接请求的丢失。

#### 4. `net.ipv4.ip_local_port_range`
- **定义**: 此参数设置了可用的本地端口范围。
- **作用**: 当创建新的连接时，操作系统会使用本地端口作为源端口。该参数指定了可以使用的本地端口的范围。默认情况下，端口范围较小，可能不足以支持大量并发连接。
- **建议值**: 将其设置为 `1024 65535`，可以为新的连接提供更多的可用端口，减少端口耗尽的风险。

#### 5. `net.ipv4.tcp_tw_reuse`
- **定义**: 此参数控制 TCP 连接的 TIME_WAIT 状态是否可以被重用。
- **作用**: 当 TCP 连接关闭后，会进入 TIME_WAIT 状态，以确保数据包可以安全地被处理。默认情况下，这个状态会占用一个端口，`tcp_tw_reuse` 允许在 TIME_WAIT 状态下的连接重用，减少可用端口的消耗。
- **建议值**: 设置为 `1`（启用重用），可以提高服务器在高并发场景下的性能。

#### 6. `net.ipv4.tcp_fin_timeout`
- **定义**: 此参数设置 TCP 连接在 FIN_WAIT 状态下的超时时间。
- **作用**: 在 TCP 连接关闭过程中，连接会进入 FIN_WAIT 状态，等待另一方确认关闭。`tcp_fin_timeout` 定义了在这个状态下的最长持续时间，超时后连接将被强制关闭。
- **建议值**: 设置为较短的时间（如 `30` 秒），可以帮助快速释放无效的连接，特别是在高负载情况下。

### 总结
这些参数可以帮助操作系统更有效地处理大量并发连接，减少连接丢失、延迟和资源耗尽的问题。在调整这些参数时，建议监控系统性能，以确保设置的有效性和稳定性。


### 查看当前进程线程数量

`pstree  -p 263042 | wc -l`

> 263042 表示进程ID

### 监控SYN_RECV状态的连接数（可能表示SYN Flood攻击或网络阻塞）
> watch "netstat -ant | grep SYN_RECV | wc -l"